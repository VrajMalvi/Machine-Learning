# -*- coding: utf-8 -*-
"""SOM_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mlP6dJuCSEDlqk1DVaQiU3HLTN2WDg9

#Self Organizing Map

# Un-Supervised Learning:



*   Fraud detection using Self Organizing Map (SOM)
*   in dataset 0 represents files which are not approved and 1 represents files which are approved

*   Here our goal is to find potential fraud rather than predicting 0 or 1

##Install MiniSom Package
"""

!pip install MiniSom

"""### Importing the libraries

"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""## Importing the dataset"""

dataset = pd.read_csv('Credit_Card_Applications.csv')
X = dataset.iloc[:, :-1].values # here we are keeping customerID as we need ID to trace back to fraud customer
y = dataset.iloc[:, -1].values

dataset

"""## Feature Scaling

"""

from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler(feature_range = (0,1))
X = sc.fit_transform(X)

"""##Training the SOM


*  X and y: These parameters determine the dimensions of the SOM grid. In this case, you are creating a 10x10 grid, meaning there are 10 rows and 10 columns of nodes in the SOM.

*  input_len: This parameter specifies the dimensionality of the input data. Each input data point is expected to have 15 features.

*  sigma: Sigma is the radius of influence of each node during training. A larger sigma means a broader influence, and a smaller sigma means a more localized influence.

*  learning_rate: This parameter controls the rate at which the SOM learns from the input data. A higher learning rate means faster learning, while a lower rate means slower and more stable learning.






"""

from minisom import MiniSom
som = MiniSom(x = 10, y = 10, input_len=15, sigma=1.0, learning_rate=0.5)

# randomly initializing weights and training data over 100 iterations
som.random_weights_init(X)
som.train_random(X, num_iteration=100)

"""##Visualizing the results

"""

from pylab import bone, pcolor, colorbar, plot, show
bone()
pcolor(som.distance_map().T)
colorbar()
markers = ['o', 's'] # to show which are arroved and which not. circle red- not approved, green square- approved
colors = ['r', 'g']

for i, x in enumerate(X):
  w = som.winner(x)  # this gives us winning node for customer at point x
  plot(w[0] + 0.5,
       w[1] + 0.5,
       markers[y[i]],
       markeredgecolor = colors[y[i]],
       markerfacecolor = 'None',
       markersize = 10,
       markeredgewidth = 2)
show()

# NOTE: each time you run SOM it might give different output then before so you have to change below code section based on output

"""## Finding the frauds

### using a trained Self-Organizing Map (SOM) to find and concatenate data points that are associated with specific grid nodes. Let's break down what each line is doing:

* mappings = som.win_map(X): This line maps or associates the input data X to the nodes on the SOM grid. The resulting mappings variable is a dictionary where the keys are coordinates of the grid nodes (e.g., (5, 1)) and the values are lists of data points from X that map to those nodes.

* frauds = np.concatenate((mappings[(5, 1)], mappings[(7, 3)]), axis=0): Here, you are concatenating the data points that map to two specific grid nodes, (5, 1) and (7, 3). You use the np.concatenate function to combine these data points along axis=0, which means they will be stacked vertically to form a single array.
"""

mappings = som.win_map(X)
# so here we are taking data points which are highlighted strongly representing outlier(potential fraud customer)
frauds = np.concatenate((mappings[(5,1)], mappings[(7,3)]), axis = 0)
frauds = sc.inverse_transform(frauds)

"""##Printing the Fraunch Clients"""

print('Fraud Customer IDs')
for i in frauds[:, 0]:
  print(int(i))